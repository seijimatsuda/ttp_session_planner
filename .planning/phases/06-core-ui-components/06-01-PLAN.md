---
phase: 06-core-ui-components
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/src/lib/utils.ts
  - frontend/src/components/feedback/Toaster.tsx
  - frontend/src/components/feedback/ErrorFallback.tsx
  - frontend/src/components/feedback/index.ts
autonomous: true

must_haves:
  truths:
    - "cn() utility combines classes without Tailwind conflicts"
    - "Toast notifications can be triggered from anywhere in app"
    - "Error boundary catches rendering errors and shows user-friendly fallback"
  artifacts:
    - path: "frontend/src/lib/utils.ts"
      provides: "cn() utility function"
      exports: ["cn"]
      contains: "twMerge"
    - path: "frontend/src/components/feedback/Toaster.tsx"
      provides: "Sonner toast wrapper"
      exports: ["Toaster"]
    - path: "frontend/src/components/feedback/ErrorFallback.tsx"
      provides: "User-friendly error UI"
      exports: ["ErrorFallback", "AppErrorBoundary"]
  key_links:
    - from: "frontend/src/lib/utils.ts"
      to: "clsx + tailwind-merge"
      via: "import"
      pattern: "import.*clsx|twMerge"
    - from: "frontend/src/components/feedback/Toaster.tsx"
      to: "sonner"
      via: "import"
      pattern: "from.*sonner"
---

<objective>
Install UI component library dependencies and create foundational utilities for the component system.

Purpose: Establishes the building blocks (cn() utility, toast system, error handling) that all other UI components will use. This must be done first so subsequent plans can use these patterns.

Output: Dependencies installed, cn() utility working, feedback components ready to wire into App.tsx
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-core-ui-components/06-RESEARCH.md

# Reference for current frontend structure
@frontend/package.json
@frontend/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install UI component library dependencies</name>
  <files>frontend/package.json</files>
  <action>
Install the UI component libraries identified in research:

```bash
cd frontend && npm install sonner react-loading-skeleton react-hook-form zod @hookform/resolvers react-error-boundary clsx tailwind-merge
```

These are the exact versions from research:
- sonner (2.0.7) - toast notifications
- react-loading-skeleton (3.5.0) - skeleton loading
- react-hook-form (7.71.x) - form state management
- zod (4.3.5) - schema validation
- @hookform/resolvers (5.2.2) - form+zod integration
- react-error-boundary (6.1.0) - error handling
- clsx (2.1.1) - conditional classNames
- tailwind-merge (3.4.0) - Tailwind class conflict resolution

Do NOT pin exact versions - use npm defaults (^x.y.z) for semver compatibility.
  </action>
  <verify>
Run `npm ls sonner clsx tailwind-merge react-loading-skeleton react-hook-form zod @hookform/resolvers react-error-boundary` in frontend/ - all packages listed without errors.
  </verify>
  <done>All 8 UI libraries installed and listed in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create cn() utility function</name>
  <files>frontend/src/lib/utils.ts</files>
  <action>
Create the cn() utility that combines clsx and tailwind-merge for conflict-free class composition.

This is the shadcn/ui pattern - industry standard for Tailwind component libraries.

```typescript
// frontend/src/lib/utils.ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Combines class names with Tailwind conflict resolution.
 * Uses clsx for conditional classes and tailwind-merge to resolve conflicts.
 *
 * @example
 * cn("px-4 py-2", isActive && "bg-blue-500", className)
 * cn("bg-red-500", "bg-blue-500") // Returns "bg-blue-500" (last wins)
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

This file will be the central utility location - other utilities can be added here later.
  </action>
  <verify>
Create a quick test by importing in App.tsx temporarily:
```typescript
import { cn } from './lib/utils';
console.log(cn("bg-red-500", "bg-blue-500")); // Should output "bg-blue-500"
```
Run `npm run dev` and check browser console - should log "bg-blue-500".
Remove the test code after verification.
  </verify>
  <done>cn() function exists and correctly merges conflicting Tailwind classes</done>
</task>

<task type="auto">
  <name>Task 3: Create feedback components (Toaster + ErrorFallback)</name>
  <files>
    frontend/src/components/feedback/Toaster.tsx
    frontend/src/components/feedback/ErrorFallback.tsx
    frontend/src/components/feedback/index.ts
  </files>
  <action>
Create the feedback components directory and two core components.

**Toaster.tsx** - Sonner wrapper with project-specific config:
```typescript
// frontend/src/components/feedback/Toaster.tsx
import { Toaster as SonnerToaster } from "sonner";

/**
 * Pre-configured toast notification provider.
 * Render once at app root. Use toast() from sonner anywhere in app.
 *
 * @example
 * import { toast } from "sonner";
 * toast.success("Saved!");
 * toast.error("Something went wrong. Please try again.");
 * toast.promise(saveData(), { loading: "Saving...", success: "Saved!", error: "Failed" });
 */
export function Toaster() {
  return (
    <SonnerToaster
      position="bottom-right"
      richColors
      expand={false}
      toastOptions={{
        className: "font-sans",
        duration: 4000,
      }}
    />
  );
}
```

**ErrorFallback.tsx** - User-friendly error boundary UI:
```typescript
// frontend/src/components/feedback/ErrorFallback.tsx
import { ErrorBoundary, type FallbackProps } from "react-error-boundary";
import { cn } from "@/lib/utils";

/**
 * User-friendly error fallback component.
 * Shows helpful message with retry button, not technical errors.
 */
export function ErrorFallback({ error, resetErrorBoundary }: FallbackProps) {
  return (
    <div className="min-h-[200px] flex flex-col items-center justify-center p-8 text-center">
      <div className="text-red-500 mb-4">
        <svg className="w-12 h-12 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
          />
        </svg>
      </div>

      <h2 className="text-lg font-semibold text-gray-900 mb-2">
        Something went wrong
      </h2>

      <p className="text-gray-600 mb-4 max-w-md">
        We ran into an unexpected problem. Please try again, or contact support if the issue continues.
      </p>

      <button
        onClick={resetErrorBoundary}
        className={cn(
          "min-h-11 px-6 py-2 bg-blue-600 text-white rounded-lg font-medium",
          "hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
        )}
      >
        Try Again
      </button>

      {/* Show error details in development only */}
      {import.meta.env.DEV && (
        <details className="mt-4 text-left text-sm text-gray-500 max-w-md">
          <summary className="cursor-pointer">Technical details</summary>
          <pre className="mt-2 p-2 bg-gray-100 rounded overflow-auto text-xs">
            {error.message}
          </pre>
        </details>
      )}
    </div>
  );
}

/**
 * Pre-configured error boundary wrapper.
 * Wrap major app sections to catch and recover from errors.
 *
 * @example
 * <AppErrorBoundary>
 *   <YourComponent />
 * </AppErrorBoundary>
 */
export function AppErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onError={(error, info) => {
        // Log to error tracking service in production
        console.error("Error boundary caught:", error, info);
      }}
    >
      {children}
    </ErrorBoundary>
  );
}
```

**index.ts** - Barrel export:
```typescript
// frontend/src/components/feedback/index.ts
export { Toaster } from "./Toaster";
export { ErrorFallback, AppErrorBoundary } from "./ErrorFallback";
```

**Important:** Use `@/lib/utils` import path. This requires the path alias setup from Phase 1. If not working, use relative path `../../lib/utils` as fallback.
  </action>
  <verify>
Run TypeScript check: `cd frontend && npx tsc --noEmit` - no errors in feedback components.
Check that all exports resolve: Create a temp import in App.tsx:
```typescript
import { Toaster, AppErrorBoundary } from './components/feedback';
```
If import fails, check barrel export syntax.
  </verify>
  <done>
- Toaster component exports and accepts no props
- ErrorFallback shows user-friendly message with "Try Again" button
- AppErrorBoundary wraps children in error boundary
- All components use cn() for class merging
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd frontend && npm ls` shows all 8 new dependencies
2. `npx tsc --noEmit` passes with no errors
3. Import test in App.tsx works:
   ```typescript
   import { cn } from './lib/utils';
   import { Toaster, AppErrorBoundary } from './components/feedback';
   ```
4. `npm run build` succeeds
</verification>

<success_criteria>
- [ ] 8 UI libraries installed (sonner, react-loading-skeleton, react-hook-form, zod, @hookform/resolvers, react-error-boundary, clsx, tailwind-merge)
- [ ] cn() utility function works and resolves Tailwind conflicts
- [ ] Toaster component ready to render at app root
- [ ] ErrorFallback and AppErrorBoundary ready for use
- [ ] TypeScript compilation passes
- [ ] Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-ui-components/06-01-SUMMARY.md`
</output>
