---
phase: 09-drill-detail-edit
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - frontend/src/components/drills/DrillForm.tsx
  - frontend/src/pages/EditDrillPage.tsx
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can navigate to /drills/:id/edit and see pre-populated form"
    - "User can modify any field and save changes"
    - "Form shows existing media with option to replace or remove"
    - "Successful update navigates back to detail page with toast"
    - "Update persists to database"
  artifacts:
    - path: "frontend/src/components/drills/DrillForm.tsx"
      provides: "Reusable form supporting create and edit modes"
      min_lines: 100
    - path: "frontend/src/pages/EditDrillPage.tsx"
      provides: "Edit page with data loading and form wrapper"
      min_lines: 50
  key_links:
    - from: "frontend/src/components/drills/DrillForm.tsx"
      to: "useUpdateDrill mutation"
      via: "edit mode uses mutateAsync"
      pattern: "useUpdateDrill"
    - from: "frontend/src/pages/EditDrillPage.tsx"
      to: "DrillForm"
      via: "passes drill prop for edit mode"
      pattern: "drill=\\{drill\\}"
---

<objective>
Make DrillForm reusable for both create and edit modes, create EditDrillPage for modifying existing drills.

Purpose: Allow users to update any field of their drills, reusing the existing form infrastructure.
Output: EditDrillPage route at /drills/:id/edit with pre-populated DrillForm.
</objective>

<execution_context>
@/Users/seijimatsuda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/seijimatsuda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-drill-detail-edit/09-RESEARCH.md
@.planning/phases/09-drill-detail-edit/09-01-SUMMARY.md

# Existing code to modify
@frontend/src/components/drills/DrillForm.tsx
@frontend/src/components/drills/DrillForm.schema.ts
@frontend/src/hooks/useDrills.ts
@frontend/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make DrillForm reusable for create and edit modes</name>
  <files>
    frontend/src/components/drills/DrillForm.tsx
  </files>
  <action>
1. Update DrillFormProps interface to accept optional drill for edit mode:
   ```typescript
   interface DrillFormProps {
     /** Drill to edit - if provided, form is in edit mode */
     drill?: Drill;
     /** Callback after successful creation or update */
     onSuccess?: (drillId: string) => void;
   }
   ```

2. Add isEditMode computed value: `const isEditMode = !!drill;`

3. Import useUpdateDrill alongside useCreateDrill from @/hooks/useDrills

4. Conditionally set defaultValues based on mode:
   ```typescript
   const defaultValues = drill
     ? {
         name: drill.name,
         category: drill.category || "activation",
         num_players: drill.num_players ?? undefined,
         equipment: drill.equipment || [],
         tags: drill.tags || [],
         video_url: drill.video_url || "",
       }
     : drillFormDefaults;
   ```

5. Initialize mediaFilePath state with existing media in edit mode:
   ```typescript
   const [mediaFilePath, setMediaFilePath] = useState<string | null>(
     drill?.video_file_path ?? null
   );
   ```

6. Update onSubmit handler to branch based on mode:
   - Create mode: Use createDrill.mutateAsync (existing code)
   - Edit mode: Use updateDrill.mutateAsync({ id: drill.id, updates: {...} })
   - Edit mode should NOT reset form after success (navigate instead)
   - Both modes call onSuccess callback with drill ID

7. Update isFormDisabled to include updateDrill.isPending:
   ```typescript
   const isFormDisabled = isSubmitting || createDrill.isPending || updateDrill.isPending || isUploading;
   ```

8. Update submit button text:
   - Create mode: "Create Drill" / "Creating..."
   - Edit mode: "Update Drill" / "Updating..."

9. Pass initialFilePath to MediaUpload in edit mode:
   ```typescript
   <MediaUpload
     initialFilePath={mediaFilePath || undefined}
     initialMediaType={mediaType || undefined}
     // ... other props
   />
   ```

10. When media is deleted in edit mode (onDelete callback fires), set mediaFilePath to null - this allows removing media without replacement
  </action>
  <verify>
- `npx tsc --noEmit` passes
- DrillForm accepts optional drill prop
- Both useCreateDrill and useUpdateDrill are imported
  </verify>
  <done>
- DrillForm supports both create and edit modes
- Edit mode pre-populates form with drill data
- Edit mode uses useUpdateDrill mutation
- Button text changes based on mode
- Media state initializes from existing drill
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EditDrillPage and wire route</name>
  <files>
    frontend/src/pages/EditDrillPage.tsx
    frontend/src/App.tsx
  </files>
  <action>
1. Create EditDrillPage.tsx that:
   - Uses useParams<{ id: string }>() to extract drill ID
   - Uses useDrill(id) to fetch drill data
   - Uses useNavigate() for navigation

2. Handle three states:
   a. Loading: Skeleton placeholders for form fields
      - Similar pattern to DrillDetailPage but matching form layout
   b. Error/Not Found: "Drill Not Found" message with back button
   c. Success: DrillForm with drill prop for edit mode

3. Wrap in AppShell for consistent layout with header/sidebar

4. Page title: "Edit Drill" as h1

5. onSuccess callback navigates to /drills/{id} (back to detail page)
   ```typescript
   const handleSuccess = (drillId: string) => {
     navigate(`/drills/${drillId}`);
   };
   ```

6. Add route to App.tsx:
   - Add: `<Route path="/drills/:id/edit" element={<EditDrillPage />} />`
   - Place AFTER /drills/:id route
   - Import EditDrillPage at top of file

7. Route order in App.tsx should be:
   ```
   /drills/new (most specific)
   /drills/:id/edit (specific pattern)
   /drills/:id (dynamic)
   /drills (base)
   ```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- Route /drills/:id/edit exists in App.tsx
- EditDrillPage is imported in App.tsx
  </verify>
  <done>
- EditDrillPage loads drill and renders DrillForm in edit mode
- Route /drills/:id/edit wired in App.tsx
- Loading/error states handled
- Successful update navigates to detail page
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. Dev server runs without errors
3. Create a drill via /drills/new
4. Navigate to /drills/{id}/edit - form pre-populated with drill data
5. Modify fields (name, category, tags, etc.)
6. Submit form - toast shows success, redirects to detail page
7. Verify changes persisted on detail page
8. Test media: edit existing drill with video, upload new video, verify old replaced
9. Test media removal: delete media in edit mode, save, verify media removed
</verification>

<success_criteria>
- DrillForm reusable for both create and edit modes
- Edit mode pre-populates all fields from existing drill
- Successful update shows toast and navigates to detail page
- Changes persist to database (verify via detail page)
- Media can be replaced or removed during edit
- Route /drills/:id/edit correctly wired
</success_criteria>

<output>
After completion, create `.planning/phases/09-drill-detail-edit/09-02-SUMMARY.md`
</output>
