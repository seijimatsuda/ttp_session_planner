---
phase: 03-database-schema-services
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - frontend/src/lib/database.types.ts
  - frontend/src/lib/supabase.ts
  - frontend/src/services/drills.service.ts
  - frontend/src/services/sessions.service.ts
  - frontend/src/providers/QueryProvider.tsx
  - frontend/src/main.tsx
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "TypeScript types match database schema exactly"
    - "Service functions exist for all CRUD operations on drills"
    - "Service functions exist for all CRUD operations on sessions"
    - "QueryProvider wraps the application"
  artifacts:
    - path: "frontend/src/lib/database.types.ts"
      provides: "Generated TypeScript types for database schema"
      contains: "Database"
    - path: "frontend/src/services/drills.service.ts"
      provides: "Drill CRUD operations"
      exports: ["getDrillsByUser", "createDrill", "updateDrill", "deleteDrill"]
    - path: "frontend/src/services/sessions.service.ts"
      provides: "Session CRUD operations"
      exports: ["getSessionsByUser", "createSession", "updateSession", "deleteSession"]
    - path: "frontend/src/providers/QueryProvider.tsx"
      provides: "TanStack Query setup"
      contains: "QueryClientProvider"
  key_links:
    - from: "frontend/src/services/drills.service.ts"
      to: "frontend/src/lib/database.types.ts"
      via: "import type"
      pattern: "import.*Database.*from.*database.types"
    - from: "frontend/src/main.tsx"
      to: "frontend/src/providers/QueryProvider.tsx"
      via: "wraps App"
      pattern: "QueryProvider"
---

<objective>
Create TypeScript types from database schema, set up TanStack Query, and build service layer for data operations.

Purpose: Establish type-safe data access patterns. Service layer centralizes Supabase queries, making them reusable and testable. TanStack Query handles caching, loading states, and error handling.

Output: Type-safe service functions for drills and sessions, QueryProvider ready for hooks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-database-schema-services/03-RESEARCH.md
@.planning/phases/03-database-schema-services/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install TanStack Query and create database types</name>
  <files>
    frontend/package.json
    frontend/src/lib/database.types.ts
  </files>
  <action>
Install TanStack Query in the frontend:

```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
npm install @tanstack/react-query
```

Create `frontend/src/lib/database.types.ts` with the TypeScript types matching our schema:

```typescript
/**
 * Database types for Supabase
 *
 * These types mirror the database schema created in Phase 3 Plan 01.
 * When schema changes, regenerate with: npx supabase gen types typescript --project-id "$PROJECT_REF" > src/lib/database.types.ts
 *
 * For now, manually defined to match our migration.
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type DrillCategory = 'activation' | 'dribbling' | 'passing' | 'shooting'

export interface Database {
  public: {
    Tables: {
      drills: {
        Row: {
          id: string
          created_at: string
          name: string
          video_url: string | null
          video_file_path: string | null
          category: DrillCategory | null
          num_players: number | null
          equipment: string[] | null
          tags: string[] | null
          user_id: string
          creator_email: string | null
        }
        Insert: {
          id?: string
          created_at?: string
          name: string
          video_url?: string | null
          video_file_path?: string | null
          category?: DrillCategory | null
          num_players?: number | null
          equipment?: string[] | null
          tags?: string[] | null
          user_id: string
          creator_email?: string | null
        }
        Update: {
          id?: string
          created_at?: string
          name?: string
          video_url?: string | null
          video_file_path?: string | null
          category?: DrillCategory | null
          num_players?: number | null
          equipment?: string[] | null
          tags?: string[] | null
          user_id?: string
          creator_email?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "drills_user_id_fkey"
            columns: ["user_id"]
            referencedRelation: "users"
            referencedColumns: ["id"]
          }
        ]
      }
      sessions: {
        Row: {
          id: string
          created_at: string
          name: string
          grid_data: Json
          user_id: string
          creator_email: string | null
        }
        Insert: {
          id?: string
          created_at?: string
          name: string
          grid_data?: Json
          user_id: string
          creator_email?: string | null
        }
        Update: {
          id?: string
          created_at?: string
          name?: string
          grid_data?: Json
          user_id?: string
          creator_email?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "sessions_user_id_fkey"
            columns: ["user_id"]
            referencedRelation: "users"
            referencedColumns: ["id"]
          }
        ]
      }
    }
    Views: {}
    Functions: {}
    Enums: {}
    CompositeTypes: {}
  }
}

// Convenience type aliases
export type Drill = Database['public']['Tables']['drills']['Row']
export type DrillInsert = Database['public']['Tables']['drills']['Insert']
export type DrillUpdate = Database['public']['Tables']['drills']['Update']

export type Session = Database['public']['Tables']['sessions']['Row']
export type SessionInsert = Database['public']['Tables']['sessions']['Insert']
export type SessionUpdate = Database['public']['Tables']['sessions']['Update']

// Grid data type for session planner (4 rows x 3 columns)
export interface GridCell {
  drillId: string | null
}

export interface GridData {
  cells: {
    [key: string]: GridCell // key format: "row-col" e.g., "activation-0", "dribbling-1"
  }
}
```

Update `frontend/src/lib/supabase.ts` to use typed client:

```typescript
import { createClient } from '@supabase/supabase-js'
import type { Database } from './database.types'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables. Check .env.local')
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey)
```
  </action>
  <verify>
```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
grep -q "@tanstack/react-query" package.json && echo "TanStack Query installed"
ls src/lib/database.types.ts && echo "Database types file exists"
grep -q "export type Drill" src/lib/database.types.ts && echo "Drill type exported"
grep -q "export type Session" src/lib/database.types.ts && echo "Session type exported"
grep -q "createClient<Database>" src/lib/supabase.ts && echo "Supabase client typed"
npx tsc --noEmit && echo "TypeScript compiles"
```
  </verify>
  <done>TanStack Query installed and database types created with Drill and Session types</done>
</task>

<task type="auto">
  <name>Task 2: Create service layer for drills and sessions</name>
  <files>
    frontend/src/services/drills.service.ts
    frontend/src/services/sessions.service.ts
  </files>
  <action>
Create services directory and service files:

```bash
mkdir -p /Users/seijimatsuda/session_planner_1-22-26/frontend/src/services
```

Create `frontend/src/services/drills.service.ts`:

```typescript
/**
 * Drill service - CRUD operations for drills table
 *
 * All functions use .throwOnError() so React Query properly handles errors.
 * Functions accept a Supabase client to enable both authenticated and admin operations.
 */

import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database, DrillInsert, DrillUpdate } from '../lib/database.types'

type Client = SupabaseClient<Database>

/**
 * Get all drills for a specific user, ordered by creation date (newest first)
 */
export async function getDrillsByUser(client: Client, userId: string) {
  const { data, error } = await client
    .from('drills')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}

/**
 * Get a single drill by ID
 */
export async function getDrillById(client: Client, id: string) {
  const { data, error } = await client
    .from('drills')
    .select('*')
    .eq('id', id)
    .single()

  if (error) throw error
  return data
}

/**
 * Get drills filtered by category
 */
export async function getDrillsByCategory(
  client: Client,
  userId: string,
  category: string
) {
  const { data, error } = await client
    .from('drills')
    .select('*')
    .eq('user_id', userId)
    .eq('category', category)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}

/**
 * Search drills by name (case-insensitive partial match)
 */
export async function searchDrills(
  client: Client,
  userId: string,
  searchTerm: string
) {
  const { data, error } = await client
    .from('drills')
    .select('*')
    .eq('user_id', userId)
    .ilike('name', `%${searchTerm}%`)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}

/**
 * Create a new drill
 */
export async function createDrill(client: Client, drill: DrillInsert) {
  const { data, error } = await client
    .from('drills')
    .insert(drill)
    .select()
    .single()

  if (error) throw error
  return data
}

/**
 * Update an existing drill
 */
export async function updateDrill(
  client: Client,
  id: string,
  updates: DrillUpdate
) {
  const { data, error } = await client
    .from('drills')
    .update(updates)
    .eq('id', id)
    .select()
    .single()

  if (error) throw error
  return data
}

/**
 * Delete a drill by ID
 */
export async function deleteDrill(client: Client, id: string) {
  const { error } = await client
    .from('drills')
    .delete()
    .eq('id', id)

  if (error) throw error
}
```

Create `frontend/src/services/sessions.service.ts`:

```typescript
/**
 * Session service - CRUD operations for sessions table
 *
 * All functions use .throwOnError() so React Query properly handles errors.
 * Functions accept a Supabase client to enable both authenticated and admin operations.
 */

import type { SupabaseClient } from '@supabase/supabase-js'
import type { Database, SessionInsert, SessionUpdate } from '../lib/database.types'

type Client = SupabaseClient<Database>

/**
 * Get all sessions for a specific user, ordered by creation date (newest first)
 */
export async function getSessionsByUser(client: Client, userId: string) {
  const { data, error } = await client
    .from('sessions')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}

/**
 * Get a single session by ID
 */
export async function getSessionById(client: Client, id: string) {
  const { data, error } = await client
    .from('sessions')
    .select('*')
    .eq('id', id)
    .single()

  if (error) throw error
  return data
}

/**
 * Create a new session
 */
export async function createSession(client: Client, session: SessionInsert) {
  const { data, error } = await client
    .from('sessions')
    .insert(session)
    .select()
    .single()

  if (error) throw error
  return data
}

/**
 * Update an existing session
 */
export async function updateSession(
  client: Client,
  id: string,
  updates: SessionUpdate
) {
  const { data, error } = await client
    .from('sessions')
    .update(updates)
    .eq('id', id)
    .select()
    .single()

  if (error) throw error
  return data
}

/**
 * Delete a session by ID
 */
export async function deleteSession(client: Client, id: string) {
  const { error } = await client
    .from('sessions')
    .delete()
    .eq('id', id)

  if (error) throw error
}
```

IMPORTANT NOTES:
- All functions throw errors instead of returning them, enabling React Query error handling
- Functions accept client as parameter for flexibility (can use authenticated or admin client)
- user_id filtering happens at service level in addition to RLS for explicit queries
  </action>
  <verify>
```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
ls src/services/drills.service.ts && echo "Drills service exists"
ls src/services/sessions.service.ts && echo "Sessions service exists"
grep -q "export async function getDrillsByUser" src/services/drills.service.ts && echo "getDrillsByUser exported"
grep -q "export async function createDrill" src/services/drills.service.ts && echo "createDrill exported"
grep -q "export async function getSessionsByUser" src/services/sessions.service.ts && echo "getSessionsByUser exported"
grep -q "export async function createSession" src/services/sessions.service.ts && echo "createSession exported"
npx tsc --noEmit && echo "TypeScript compiles"
```
  </verify>
  <done>Service layer created with type-safe CRUD operations for drills and sessions</done>
</task>

<task type="auto">
  <name>Task 3: Set up QueryProvider and wire into app</name>
  <files>
    frontend/src/providers/QueryProvider.tsx
    frontend/src/main.tsx
  </files>
  <action>
Create providers directory:

```bash
mkdir -p /Users/seijimatsuda/session_planner_1-22-26/frontend/src/providers
```

Create `frontend/src/providers/QueryProvider.tsx`:

```typescript
/**
 * TanStack Query Provider
 *
 * Provides QueryClient to the entire application.
 * Configured with sensible defaults for a Supabase-backed app.
 */

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState, type ReactNode } from 'react'

interface QueryProviderProps {
  children: ReactNode
}

export function QueryProvider({ children }: QueryProviderProps) {
  // Create QueryClient inside component to avoid sharing state between requests (SSR safety)
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // Data is considered fresh for 1 minute
            staleTime: 60 * 1000,
            // Retry failed requests once
            retry: 1,
            // Don't refetch on window focus for this app (data doesn't change that frequently)
            refetchOnWindowFocus: false,
          },
          mutations: {
            // Retry mutations once on failure
            retry: 1,
          },
        },
      })
  )

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
```

Update `frontend/src/main.tsx` to wrap App with QueryProvider:

```typescript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import { QueryProvider } from './providers/QueryProvider.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <QueryProvider>
      <App />
    </QueryProvider>
  </StrictMode>,
)
```
  </action>
  <verify>
```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
ls src/providers/QueryProvider.tsx && echo "QueryProvider exists"
grep -q "QueryClientProvider" src/providers/QueryProvider.tsx && echo "QueryClientProvider used"
grep -q "QueryProvider" src/main.tsx && echo "QueryProvider imported in main.tsx"
grep -q "<QueryProvider>" src/main.tsx && echo "App wrapped with QueryProvider"
npx tsc --noEmit && echo "TypeScript compiles"
```
  </verify>
  <done>QueryProvider set up and wired into application</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All files exist with correct exports:
```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
ls -la src/lib/database.types.ts src/lib/supabase.ts
ls -la src/services/drills.service.ts src/services/sessions.service.ts
ls -la src/providers/QueryProvider.tsx
```

2. TypeScript compilation succeeds:
```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
npx tsc --noEmit
```

3. Dev server starts without errors:
```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
npm run dev &
sleep 5
curl -s http://localhost:5173 | head -20
kill %1 2>/dev/null
```
</verification>

<success_criteria>
- [ ] `database.types.ts` exports Database, Drill, DrillInsert, DrillUpdate, Session, SessionInsert, SessionUpdate types
- [ ] `supabase.ts` creates typed client with `createClient<Database>`
- [ ] `drills.service.ts` exports getDrillsByUser, getDrillById, createDrill, updateDrill, deleteDrill
- [ ] `sessions.service.ts` exports getSessionsByUser, getSessionById, createSession, updateSession, deleteSession
- [ ] `QueryProvider.tsx` wraps app with QueryClientProvider
- [ ] `main.tsx` imports and uses QueryProvider
- [ ] All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-database-schema-services/03-02-SUMMARY.md`
</output>
