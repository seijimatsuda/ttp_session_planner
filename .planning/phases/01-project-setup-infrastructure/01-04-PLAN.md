---
phase: 01-project-setup-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["03"]
files_modified:
  - frontend/package.json
  - backend/package.json
  - backend/src/app.ts
autonomous: false

user_setup:
  - service: vercel
    why: "Frontend hosting"
    env_vars:
      - name: VITE_SUPABASE_URL
        source: "Same value as local .env.local"
      - name: VITE_SUPABASE_ANON_KEY
        source: "Same value as local .env.local"
      - name: VITE_API_URL
        source: "Render backend URL (after deploying backend)"
    dashboard_config:
      - task: "Link Vercel to GitHub repo"
        location: "vercel.com/dashboard -> Import Project"
  - service: render
    why: "Backend hosting"
    env_vars:
      - name: SUPABASE_URL
        source: "Same value as local .env"
      - name: SUPABASE_ANON_KEY
        source: "Same value as local .env"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Same value as local .env"
      - name: FRONTEND_URL
        source: "Vercel frontend URL (after deploying frontend)"
      - name: NODE_ENV
        source: "production"
    dashboard_config:
      - task: "Create Web Service from repo"
        location: "render.com/dashboard -> New Web Service"

must_haves:
  truths:
    - "Frontend is accessible at a Vercel production URL"
    - "Backend is accessible at a Render production URL"
    - "Frontend can call backend API without CORS errors"
    - "Backend health endpoint works in production"
  artifacts:
    - path: "frontend/package.json"
      provides: "Build script for Vercel"
      contains: "build"
    - path: "backend/package.json"
      provides: "Build and start scripts for Render"
      contains: "start"
  key_links:
    - from: "frontend (Vercel)"
      to: "backend (Render)"
      via: "VITE_API_URL env var"
      pattern: "fetch.*VITE_API_URL"
    - from: "backend (Render)"
      to: "frontend (Vercel)"
      via: "CORS origin"
      pattern: "origin.*FRONTEND_URL"
---

<objective>
Deploy frontend to Vercel and backend to Render, then configure CORS for production communication.

Purpose: Complete the infrastructure setup by making the application accessible on the internet. This validates the full stack works end-to-end.

Output: Live URLs for both frontend and backend, with verified cross-origin communication.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-project-setup-infrastructure/01-RESEARCH.md
@.planning/phases/01-project-setup-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prepare projects for deployment</name>
  <files>
    frontend/package.json
    backend/package.json
    frontend/.gitignore
    backend/.gitignore
  </files>
  <action>
Ensure frontend build script includes TypeScript check:

Update frontend/package.json scripts (if not already):

```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint ."
  }
}
```

Verify backend has correct scripts in package.json:

```json
{
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  }
}
```

Create/update .gitignore files:

Frontend .gitignore:
```
node_modules
dist
.env.local
.env.*.local
*.log
```

Backend .gitignore:
```
node_modules
dist
.env
*.log
```

Initialize git repository if not exists:

```bash
cd /Users/seijimatsuda/session_planner_1-22-26
git init
git add .
git commit -m "Initial commit: Frontend and backend with Supabase integration"
```

Test that builds work locally:

```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
npm run build

cd /Users/seijimatsuda/session_planner_1-22-26/backend
npm run build
```

Update backend/src/app.ts with production-ready CORS configuration:

```typescript
import express, { Request, Response, NextFunction } from 'express'
import cors from 'cors'
import { supabaseAdmin } from './config/supabase.js'

const app = express()

// CORS configuration - handles both local and production
const allowedOrigins = [
  process.env.FRONTEND_URL || 'http://localhost:5173',
  // Add additional origins if needed
].filter(Boolean)

app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or Postman)
    if (!origin) return callback(null, true)

    if (allowedOrigins.includes(origin)) {
      callback(null, true)
    } else {
      console.warn(`CORS blocked origin: ${origin}`)
      callback(new Error('Not allowed by CORS'))
    }
  },
  credentials: true
}))

app.use(express.json())
app.use(express.urlencoded({ extended: true }))

// Health check endpoint (Render uses this)
app.get('/health', (req: Request, res: Response) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    service: 'soccer-session-planner-api',
    environment: process.env.NODE_ENV || 'development'
  })
})

// Root endpoint
app.get('/', (req: Request, res: Response) => {
  res.json({
    message: 'Soccer Session Planner API',
    version: '1.0.0',
    endpoints: {
      health: '/health',
      testDb: '/api/test-db'
    }
  })
})

// Database connection test
app.get('/api/test-db', async (req: Request, res: Response) => {
  try {
    const { error } = await supabaseAdmin.from('_test').select('*').limit(1)
    if (error && error.code !== '42P01') {
      throw error
    }
    res.json({
      status: 'connected',
      message: 'Supabase connection successful'
    })
  } catch (err) {
    res.status(500).json({
      status: 'error',
      message: err instanceof Error ? err.message : 'Unknown error'
    })
  }
})

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err.stack)
  res.status(500).json({ error: 'Something went wrong!' })
})

export default app
```
  </action>
  <verify>
```bash
cd /Users/seijimatsuda/session_planner_1-22-26/frontend
npm run build && ls dist/index.html && echo "Frontend builds"

cd /Users/seijimatsuda/session_planner_1-22-26/backend
npm run build && ls dist/server.js && echo "Backend builds"

git status
```
  </verify>
  <done>Both projects build successfully and are ready for deployment</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Deploy backend to Render</name>
  <action>
User must deploy to Render using their account.
  </action>
  <instructions>
1. Push code to GitHub:
   ```bash
   cd /Users/seijimatsuda/session_planner_1-22-26
   git add .
   git commit -m "Prepare for deployment"
   git remote add origin YOUR_GITHUB_REPO_URL
   git push -u origin main
   ```

2. Go to https://render.com/dashboard

3. Click "New" -> "Web Service"

4. Connect your GitHub repository

5. Configure the service:
   - **Name**: soccer-session-planner-api
   - **Root Directory**: backend
   - **Build Command**: npm install && npm run build
   - **Start Command**: npm start
   - **Environment**: Node

6. Add Environment Variables (click "Add Environment Variable"):
   - SUPABASE_URL = [your Supabase URL]
   - SUPABASE_ANON_KEY = [your anon key]
   - SUPABASE_SERVICE_ROLE_KEY = [your service role key]
   - NODE_ENV = production
   - (FRONTEND_URL will be added after frontend deploys)

7. Click "Create Web Service"

8. Wait for deployment to complete (2-5 minutes)

9. Test the health endpoint at: https://YOUR_SERVICE_NAME.onrender.com/health
  </instructions>
  <resume-signal>
Provide the Render backend URL:
RENDER_URL: https://[your-service-name].onrender.com

Or type "deployed" with the URL.
  </resume-signal>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 3: Deploy frontend to Vercel</name>
  <action>
User must deploy to Vercel using their account.
  </action>
  <instructions>
1. Go to https://vercel.com/dashboard

2. Click "Add New" -> "Project"

3. Import your GitHub repository

4. Configure the project:
   - **Framework Preset**: Vite
   - **Root Directory**: frontend
   - **Build Command**: npm run build (auto-detected)
   - **Output Directory**: dist (auto-detected)

5. Add Environment Variables (expand "Environment Variables"):
   - VITE_SUPABASE_URL = [your Supabase URL]
   - VITE_SUPABASE_ANON_KEY = [your anon key]
   - VITE_API_URL = [your Render backend URL from Task 2]

6. Click "Deploy"

7. Wait for deployment to complete (1-2 minutes)

8. Note your Vercel URL: https://[your-project].vercel.app
  </instructions>
  <resume-signal>
Provide the Vercel frontend URL:
VERCEL_URL: https://[your-project].vercel.app

Or type "deployed" with the URL.
  </resume-signal>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Update CORS and verify end-to-end</name>
  <what-built>
Full deployment: Frontend on Vercel, Backend on Render, connected via CORS configuration.
  </what-built>
  <how-to-verify>
1. Go to Render dashboard -> Your Web Service -> Environment

2. Add/Update the FRONTEND_URL variable:
   - FRONTEND_URL = https://[your-vercel-project].vercel.app

3. Click "Save Changes" - this will trigger a redeploy

4. Wait for redeploy to complete

5. Test end-to-end:
   - Open your Vercel frontend URL in browser
   - You should see "Supabase: Connected"
   - Open browser dev tools (F12) -> Network tab
   - Refresh the page
   - Look for any CORS errors (there should be none)

6. Test backend from frontend (in browser console on the Vercel frontend):
   ```javascript
   fetch('https://YOUR_RENDER_URL.onrender.com/health')
     .then(r => r.json())
     .then(console.log)
   ```
   Expected: Should return JSON with status "ok" and no CORS errors.

7. Test backend health directly:
   ```bash
   curl https://YOUR_RENDER_URL.onrender.com/health
   ```
   Expected: `{"status":"ok","timestamp":"...","service":"soccer-session-planner-api","environment":"production"}`
  </how-to-verify>
  <resume-signal>
Confirm everything works:
- Frontend loads at Vercel URL: [yes/no]
- Supabase shows "Connected": [yes/no]
- No CORS errors: [yes/no]
- Backend health endpoint accessible: [yes/no]

Or describe any issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Frontend accessible:
```bash
curl -I https://YOUR_VERCEL_URL.vercel.app
```

2. Backend accessible:
```bash
curl https://YOUR_RENDER_URL.onrender.com/health
```

3. CORS working (test in browser console on Vercel frontend):
```javascript
fetch('https://YOUR_RENDER_URL.onrender.com/health')
  .then(r => r.json())
  .then(console.log)
```
</verification>

<success_criteria>
- [ ] Frontend deployed to Vercel and accessible
- [ ] Backend deployed to Render and /health returns 200
- [ ] Frontend shows "Supabase: Connected"
- [ ] No CORS errors when frontend calls backend
- [ ] Both environment variable sets configured correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-infrastructure/01-04-SUMMARY.md` including:
- Frontend URL (Vercel)
- Backend URL (Render)
- Any configuration notes for future reference
</output>
